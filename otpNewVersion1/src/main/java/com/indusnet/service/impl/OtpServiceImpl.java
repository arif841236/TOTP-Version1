package com.indusnet.service.impl;

import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import com.indusnet.exception.DateException;
import com.indusnet.exception.OtpException;
import com.indusnet.model.OtpModel;
import com.indusnet.model.common.Channel;
import com.indusnet.model.common.OtpRequestModel;
import com.indusnet.model.common.OtpResponse;
import com.indusnet.model.common.ProcessName;
import com.indusnet.model.common.Type;
import com.indusnet.model.common.ValidationResponce;
import com.indusnet.repository.IOtpRepository;
import com.indusnet.service.IOtpService;
import com.indusnet.util.Util;
import lombok.extern.slf4j.Slf4j;
/**
 * This is service layer to hold all business logic
 */
@Service
@Slf4j
public class OtpServiceImpl implements IOtpService {
	/*
	 * Initialize the repository for database connection
	 */
	@Autowired
	IOtpRepository otpRepository;

	/*
	 * Initialize the Util class for generate otp
	 */
	@Autowired
	Util util;

	/*
	 * This constructor generated for junit test case
	 */
	public OtpServiceImpl(IOtpRepository otpRepository, Util util) {
		super();
		this.otpRepository = otpRepository;
		this.util = util;
	}

	/**
	 * This method to create otp
	 */
	@Override
	public OtpResponse createOtp(OtpRequestModel otpRequestModel) {
		/*
		 * This is checking for operation type
		 */
		if (!Type.valueOf(otpRequestModel.getOperationType().toUpperCase()).equals(Type.GENERATE))
			throw new OtpException("Please enter valid operation type");

		/*
		 * This is date time formater for convert date of string to date time
		 */
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		LocalDateTime dateTime = null;
		try {
			dateTime = LocalDateTime.parse(otpRequestModel.getStartTime(), formatter);
		} catch (Exception e) {
			throw new DateException("please enter the valid Date and Time Format");
		}

		Timestamp timeStamp = Timestamp.valueOf(dateTime);
		log.info("timestamp is :" + timeStamp);
		byte[] channel = Channel.valueOf(otpRequestModel.getChannel().toUpperCase()).name().getBytes();
		String channelKey = "";
		for (int i = 0; i < channel.length; i++)
			channelKey = channelKey.concat("" + channel[i]);

		log.info("channelKey " + channelKey);

		/*
		 * This is secret key for otp generation
		 */
		String secret = "" + timeStamp.toInstant().toEpochMilli() + otpRequestModel.getMobile() + channelKey;

		/*
		 * This OTP is generated by Util class with help of HmacSHA256
		 */
		String otp = Util.generateTOTP256(secret, otpRequestModel.getDuration(), otpRequestModel.getDigit().toString());
		log.info("otp is :" + otp);

		/*
		 * Get OtpModel from database with help of mobile number
		 */
		OtpModel model = otpRepository.findByMobileNumber(new BigInteger(otpRequestModel.getMobile()));
		log.info("model is " + model);

		/*
		 * This is otpId and created with UUID
		 */
		String otpId = UUID.randomUUID().toString().substring(0, 8);
		if (model == null) {
			OtpModel newModel = OtpModel.builder().countryCode(BigInteger.valueOf(91))
					.mobileNumber(new BigInteger(otpRequestModel.getMobile())).createdBy(otpRequestModel.getStartTime())
					.createdOn(Timestamp.valueOf(LocalDateTime.now())).otpId(otpId).processName(ProcessName.PAYMENTS)
					.status("GENERATED").build();
			otpRepository.save(newModel);
		} else {
			OtpModel newModel = OtpModel.builder().id(model.getId()).countryCode(BigInteger.valueOf(91))
					.mobileNumber(new BigInteger(otpRequestModel.getMobile())).createdBy(otpRequestModel.getStartTime())
					.createdOn(Timestamp.valueOf(LocalDateTime.now())).otpId(otpId).processName(ProcessName.PAYMENTS)
					.status("GENERATED").build();
			otpRepository.save(newModel);
		}
		return new OtpResponse(HttpStatus.OK.value(), "Otp is successfully generated", otp,
				otpRequestModel.getDuration().toString(), otpId);
	}

	/**
	 * This method to validate otp
	 */
	@Override
	public ValidationResponce validatedOtp(OtpRequestModel otpValidationModel) {
		/*
		 * This is checking for operation type
		 */
		if (!Type.valueOf(otpValidationModel.getOperationType().toUpperCase()).equals(Type.VALIDATE))
			throw new OtpException("Please enter valid operation type");

		/*
		 * This is date time formater for convert date of string to date time
		 */
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		LocalDateTime dateTime = null;

		/*
		 * Get OtpModel from database with help of mobile number
		 */
		OtpModel otpModel = otpRepository.findByMobileNumber(new BigInteger(otpValidationModel.getMobile()));
		if (otpModel == null)
			throw new OtpException(
					"user not found in database with " + otpValidationModel.getMobile() + " mobile number.");

		LocalDateTime dateStart = null;
		try {
			dateTime = LocalDateTime.parse(otpValidationModel.getStartTime(), formatter);
			dateStart = LocalDateTime.parse(otpModel.getCreatedBy(), formatter);
		} catch (Exception e) {
			throw new DateException("please enter the valid Date and Time Format");
		}

		Timestamp timeStamp = Timestamp.valueOf(dateStart);
		log.info("timestamp is :" + timeStamp);
		byte[] channel = Channel.valueOf(otpValidationModel.getChannel().toUpperCase()).name().getBytes();
		String channelKey = "";
		for (int i = 0; i < channel.length; i++)
			channelKey = channelKey.concat("" + channel[i]);

		log.info("channelKey " + channelKey);
		String secret = "" + timeStamp.toInstant().toEpochMilli() + otpValidationModel.getMobile() + channelKey;

		/*
		 * This OTP is regenerated by Util class with help of HmacSHA256 for otp
		 * validation
		 */
		String otp = Util.generateTOTP256(secret, otpValidationModel.getDuration(),
				otpValidationModel.getDigit().toString());
		if (otp.equals(otpValidationModel.getGeneratedOtp())
				&& (dateStart.plusSeconds(180).isAfter(dateTime) || dateStart.plusSeconds(180).isEqual(dateTime))) {
			otpModel.setStatus("VERIFIED");
			otpRepository.save(otpModel);
			return ValidationResponce.builder().status(HttpStatus.OK.value()).message("OTP validated successfully")
					.build();
		}

		else if (otp.equals(otpValidationModel.getGeneratedOtp()) && dateStart.plusSeconds(180).isBefore(dateTime)) {
			return ValidationResponce.builder().status(HttpStatus.ACCEPTED.value()).message("OTP is expired").build();
		} else {
			otpModel.setStatus("FAILED");
			otpRepository.save(otpModel);
			return ValidationResponce.builder().status(HttpStatus.ACCEPTED.value()).message("Invalid otp").build();
		}
	}

}
